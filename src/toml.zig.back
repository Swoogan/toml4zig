static void* (*ppmalloc)(size_t) = malloc;
static void (*ppfree)(void*) = free;
static void* (*ppcalloc)(size_t, size_t) = calloc;
static void* (*pprealloc)(void*, size_t) = realloc;

void toml_set_memutil(void* (*xxmalloc)(size_t),
        void  (*xxfree)(void*),
        void* (*xxcalloc)(size_t, size_t),
        void* (*xxrealloc)(void*, size_t))
{
    ppmalloc = xxmalloc;
    ppfree = xxfree;
    ppcalloc = xxcalloc;
    pprealloc = xxrealloc;
}


#define MALLOC(a)     ppmalloc(a)
#define FREE(a)       ppfree(a)
#define CALLOC(a,b)   ppcalloc(a,b)
#define REALLOC(a,b)  pprealloc(a,b)

// add fn, and move return type to end
// "zdt ifn$a "zpJ
// add `fn`, remove `static` and move return type to end
// df "zdt ifn$a "zpJ
// swap indentifier <-> type order
// `]ea: ""px
// `]a: ""px

fn STRDUP(s: []const u8*) char* {
    var len: int = strlen(s);
    var p: char* = MALLOC(len+1);

    if (p) {
        memcpy(p, s, len);
        p[len] = 0;
    }

    return p;
}

fn STRNDUP(s: []const u8*, n: size_t) char* {
    var len: size_t = strnlen(s, n);
    var p: char* = MALLOC(len+1);

    if (p) {
        memcpy(p, s, len);
        p[len] = 0;
    }

    return p;
}


/// Convert a char in utf8 into UCS, and store it in *ret.
/// Return #bytes consumed or -1 on failure.
fn toml_utf8_to_ucs(orig: []const u8*, len: int, ret: int64_t*) int {
    var buf: const unsigned char* = (const unsigned char*) orig;
    var i: unsigned = *buf++;
    var v: int64_t;

   // 0x00000000 - 0x0000007F:
   // 0xxxxxxx

   if (0 == (i >> 7)) {
       if (len < 1) return -1;
       v = i;
       return *ret = v, 1;
   }
   // 0x00000080 - 0x000007FF:
   // 110xxxxx 10xxxxxx

   if (0x6 == (i >> 5)) {
       if (len < 2) return -1;
       v = i & 0x1f;
       for (int j = 0; j < 1; j++) {
           i = *buf++;
           if (0x2 != (i >> 6)) return -1;
           v = (v << 6) | (i & 0x3f);
       }
       return *ret = v, ([]const u8*) buf - orig;
   }

    // 0x00000800 - 0x0000FFFF:
    // 1110xxxx 10xxxxxx 10xxxxxx
        
        if (0xE == (i >> 4)) {
            if (len < 3) return -1;
            v = i & 0x0F;
            for (int j = 0; j < 2; j++) {
                i = *buf++;
                if (0x2 != (i >> 6)) return -1;
                v = (v << 6) | (i & 0x3f);
            }
            return *ret = v, ([]const u8*) buf - orig;
        }

    // 0x00010000 - 0x001FFFFF:
    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        
        if (0x1E == (i >> 3)) {
            if (len < 4) return -1;
            v = i & 0x07;
            for (int j = 0; j < 3; j++) {
                i = *buf++;
                if (0x2 != (i >> 6)) return -1;
                v = (v << 6) | (i & 0x3f);
            }
            return *ret = v, ([]const u8*) buf - orig;
        }

    // 0x00200000 - 0x03FFFFFF:
    // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        
        if (0x3E == (i >> 2)) {
            if (len < 5) return -1;
            v = i & 0x03;
            for (int j = 0; j < 4; j++) {
                i = *buf++;
                if (0x2 != (i >> 6)) return -1;
                v = (v << 6) | (i & 0x3f);
            }
            return *ret = v, ([]const u8*) buf - orig;
        }

        // 0x04000000 - 0x7FFFFFFF:
        // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

        if (0x7e == (i >> 1)) {
            if (len < 6) return -1;
            v = i & 0x01;
            for (int j = 0; j < 5; j++) {
                i = *buf++;
                if (0x2 != (i >> 6)) return -1;
                v = (v << 6) | (i & 0x3f);
            }
            return *ret = v, ([]const u8*) buf - orig;
        }
        return -1;
}


///  Convert a UCS char to utf8 code, and return it in buf.
///  Return #bytes used in buf to encode the char, or 
///  -1 on error.
    
fn toml_ucs_to_utf8(code: int64_t, buf: [6]char) c_int {
    // http://stackoverflow.com/questions/6240055/manually-converting-unicode-codepoints-into-utf-8-and-utf-16 
    // The UCS code values 0xd800â€“0xdfff (UTF-16 surrogates) as well
    // as 0xfffe and 0xffff (UCS noncharacters) should not appear in
    // conforming UTF-8 streams.
        
    if (0xd800 <= code and code <= 0xdfff) return -1;
    if (0xfffe <= code and code <= 0xffff) return -1;

    // 0x00000000 - 0x0000007F:
    // 0xxxxxxx

    if (code < 0) return -1;
    if (code <= 0x7F) {
        buf[0] = (unsigned char) code;
        return 1;
    }

    // 0x00000080 - 0x000007FF:
    // 110xxxxx 10xxxxxx

    if (code <= 0x000007FF) {
        buf[0] = 0xc0 | (code >> 6);
        buf[1] = 0x80 | (code & 0x3f);
        return 2;
    }

    // 0x00000800 - 0x0000FFFF:
    // 1110xxxx 10xxxxxx 10xxxxxx

    if (code <= 0x0000FFFF) {
        buf[0] = 0xe0 | (code >> 12);
        buf[1] = 0x80 | ((code >> 6) & 0x3f);
        buf[2] = 0x80 | (code & 0x3f);
        return 3;
    }

    // 0x00010000 - 0x001FFFFF:
    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

    if (code <= 0x001FFFFF) {
        buf[0] = 0xf0 | (code >> 18);
        buf[1] = 0x80 | ((code >> 12) & 0x3f);
        buf[2] = 0x80 | ((code >> 6) & 0x3f);
        buf[3] = 0x80 | (code & 0x3f);
        return 4;
    }

    // 0x00200000 - 0x03FFFFFF:
    // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

    if (code <= 0x03FFFFFF) {
        buf[0] = 0xf8 | (code >> 24);
        buf[1] = 0x80 | ((code >> 18) & 0x3f);
        buf[2] = 0x80 | ((code >> 12) & 0x3f);
        buf[3] = 0x80 | ((code >> 6) & 0x3f);
        buf[4] = 0x80 | (code & 0x3f);
        return 5;
    }

    // 0x04000000 - 0x7FFFFFFF:
    // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

    if (code <= 0x7FFFFFFF) {
        buf[0] = 0xfc | (code >> 30);
        buf[1] = 0x80 | ((code >> 24) & 0x3f);
        buf[2] = 0x80 | ((code >> 18) & 0x3f);
        buf[3] = 0x80 | ((code >> 12) & 0x3f);
        buf[4] = 0x80 | ((code >> 6) & 0x3f);
        buf[5] = 0x80 | (code & 0x3f);
        return 6;
    }

    return -1;
}


#define STRINGIFY(x) #x
#define TOSTRING(x)  STRINGIFY(x)
#define FLINE __FILE__ ":" TOSTRING(__LINE__)

static tokentype_t next_token(*Context* context, int dotisspecial);

// error routines. All these functions longjmp to context->jmp 
fn e_outofmemory(*Context* context, []const u8* fline) int {
    snprintf(context->errbuf, context->errbufsz, "ERROR: out of memory (%s)", fline);
    longjmp(context->jmp, 1);
    return -1;
}


fn e_internal_error(*Context* context, []const u8* fline) int {
    snprintf(context->errbuf, context->errbufsz, "internal error (%s)", fline);
    longjmp(context->jmp, 1);
    return -1;
}

fn e_syntax_error(*Context* context, int lineNum, []const u8* msg) int {
    snprintf(context->errbuf, context->errbufsz, "line %d: %s", lineNum, msg);
    longjmp(context->jmp, 1);
    return -1;
}

fn e_bad_key_error(*Context* context, int lineNum) int {
    snprintf(context->errbuf, context->errbufsz, "line %d: bad key", lineNum);
    longjmp(context->jmp, 1);
    return -1;
}

fn e_noimpl(*Context* context, []const u8* feature) int {
    snprintf(context->errbuf, context->errbufsz, "not implemented: %s", feature);
    longjmp(context->jmp, 1);
    return -1;
}

fn e_key_exists_error(*Context* context, int lineNum, []const u8* key) int {
    snprintf(context->errbuf, context->errbufsz,
            "line %d: key %s exists", lineNum, key);
    longjmp(context->jmp, 1);
    return -1;
}
 

fn norm_lit_str(src: []const u8*, srclen: int, multiline: int, errbuf: char*, errbufsz: int) char* {
    var dst: char* = 0;              // will write to dst[] and return it 
    var max: int   = 0;              // max size of dst[] 
    var off: int   = 0;              // cur offset in dst[] 
    var sp: []const u8* = src;
    var sq: []const u8* = src + srclen;
    var ch: int;

    // scan forward on src 
    for (;;) {
        if (off >=  max - 10) { // have some slack for misc stuff 
            char* x = REALLOC(dst, max += 50);
            if (!x) {
                xfree(dst);
                snprintf(errbuf, errbufsz, "out of memory");
                return 0;
            }
            dst = x;
        }

        // finished? 
        if (sp >= sq) break; 

        ch = *sp++;
        // control characters other than tab is not allowed 
        if ((0 <= ch and ch <= 0x08)
                || (0x0a <= ch and ch <= 0x1f)
                || (ch == 0x7f)) {
            if (! (multiline and (ch == '\r' || ch == '\n'))) {
                xfree(dst);
                snprintf(errbuf, errbufsz, "invalid char U+%04x", ch);
                return 0;
            }
        }

        // a plain copy suffice
        dst[off++] = ch;
    }

    dst[off++] = 0;
    return dst;
}


// Convert src to raw unescaped utf-8 string.
// Returns NULL if error with errmsg in errbuf.
    
fn norm_basic_str(src: []const u8*, srclen: int, multiline: int, errbuf: char*, errbufsz: int) char* {
    var dst: char* = 0;              // will write to dst[] and return it 
    var max: int   = 0;              // max size of dst[] 
    var off: int   = 0;              // cur offset in dst[] 
    var sp: []const u8* = src;
    var sq: []const u8* = src + srclen;
    var ch: int = undefined;

    // scan forward on src 
    for (;;) {
        if (off >=  max - 10) { // have some slack for misc stuff 
            char* x = REALLOC(dst, max += 50);
            if (!x) {
                xfree(dst);
                snprintf(errbuf, errbufsz, "out of memory");
                return 0;
            }
            dst = x;
        }

        // finished? 
        if (sp >= sq) break; 

        ch = *sp++;
        if (ch != '\\') {
            // these chars must be escaped: U+0000 to U+0008, U+000A to U+001F, U+007F 
            if ((0 <= ch and ch <= 0x08)
                    || (0x0a <= ch and ch <= 0x1f)
                    || (ch == 0x7f)) {
                if (! (multiline and (ch == '\r' || ch == '\n'))) {
                    xfree(dst);
                    snprintf(errbuf, errbufsz, "invalid char U+%04x", ch);
                    return 0;
                }
            }

            // a plain copy suffice
            dst[off++] = ch;
            continue;
        }

        // ch was backslash. we expect the escape char. 
        if (sp >= sq) {
            snprintf(errbuf, errbufsz, "last backslash is invalid");
            xfree(dst);
            return 0;
        }

        // for multi-line, we want to kill line-ending-backslash ... 
        if (multiline) {

            // if there is only whitespace after the backslash ...
            if (sp[strspn(sp, " \t\r")] == '\n') {
                // skip all the following whitespaces 
                sp += strspn(sp, " \t\r\n");
                continue;
            }
        }

        // get the escaped char 
        ch = *sp++;
        switch (ch) {
            case 'u': case 'U':
                {
                    var ucs: int64_t = 0;
                    var nhex: int = (ch == 'u' ? 4 : 8);
                    for (int i = 0; i < nhex; i++) {
                        if (sp >= sq) {
                            snprintf(errbuf, errbufsz, "\\%c expects %d hex chars", ch, nhex);
                            xfree(dst);
                            return 0;
                        }
                        ch = *sp++;
                        var v: int = ('0' <= ch and ch <= '9')
                            ? ch - '0'
                            : (('A' <= ch and ch <= 'F') ? ch - 'A' + 10 : -1);
                        if (-1 == v) {
                            snprintf(errbuf, errbufsz, "invalid hex chars for \\u or \\U");
                            xfree(dst);
                            return 0;
                        }
                        ucs = ucs * 16 + v;
                    }
                    var n: int = toml_ucs_to_utf8(ucs, &dst[off]);
                    if (-1 == n) {
                        snprintf(errbuf, errbufsz, "illegal ucs code in \\u or \\U");
                        xfree(dst);
                        return 0;
                    }
                    off += n;
                }
                continue;

            case 'b': ch = '\b'; break;
            case 't': ch = '\t'; break;
            case 'n': ch = '\n'; break;
            case 'f': ch = '\f'; break;
            case 'r': ch = '\r'; break;
            case '"':  ch = '"'; break;
            case '\\': ch = '\\'; break;
            default: 
                       snprintf(errbuf, errbufsz, "illegal escape char \\%c", ch);
                       xfree(dst);
                       return 0;
        }

        dst[off++] = ch;
    }

    // Cap with NUL and return it.
    dst[off++] = 0; 
    return dst;
}


// Normalize a key. Convert all special chars to raw unescaped utf-8 chars. 
fn normalize_key(context: *Context*, strtok: token_t) char* {
    var sp: []const u8* = strtok.ptr;
    var sq: []const u8* = strtok.ptr + strtok.len;
    var lineNum: int = strtok.lineNum;
    var ret: char*;
    var ch: int = *sp;
    var ebuf: char[80];

    // handle quoted string 
    if (ch == '\'' || ch == '\"') {
        // if ''' or """, take 3 chars off front and back. Else, take 1 char off. 
        var multiline: int = 0;
        if (sp[1] == ch and sp[2] == ch)  {
            sp += 3, sq -= 3;
            multiline = 1;
        }
        else
            sp++, sq--;

        if (ch == '\'') {
            // for single quote, take it verbatim. 
            if (! (ret = STRNDUP(sp, sq - sp))) {
                e_outofmemory(context, FLINE);
                return 0;       // not reached 
            }
        } else {
            // for double quote, we need to normalize 
            ret = norm_basic_str(sp, sq - sp, multiline, ebuf, sizeof(ebuf));
            if (!ret) {
                snprintf(context->errbuf, context->errbufsz, "line %d: %s", lineNum, ebuf);
                longjmp(context->jmp, 1);
            }
        }

        // newlines are not allowed in keys 
        if (strchr(ret, '\n')) {
            xfree(ret);
            e_bad_key_error(context, lineNum);
            return 0;           // not reached 
        }
        return ret;
    }

    // for bare-key allow only this regex: [A-Za-z0-9_-]+ 
    var xp: []const u8*;
    for (xp = sp; xp != sq; xp++) {
        var k: int = *xp;
        if (isalnum(k)) continue;
        if (k == '_' || k == '-') continue;
        e_bad_key_error(context, lineNum);
        return 0;               // not reached 
    }

    // dup and return it 
    if (! (ret = STRNDUP(sp, sq - sp))) {
        e_outofmemory(context, FLINE);
        return 0;               // not reached 
    }
    return ret;
}

fn key_kind(tab: *table, key: []const u8*) int {
    return check_key(tab, key, 0, 0, 0);
}

/// Create an array in an array 
    
fn create_array_in_array(context: *Context, parent: *array) *array {
    var n: int = parent->nelem;
    var base: *array*;
    if (0 == (base = (*array*) REALLOC(parent->u.arr, (n+1) * sizeof(*base)))) {
        e_outofmemory(context, FLINE);
        return 0;               // not reached 
    }
    parent->u.arr = base;

    if (0 == (base[n] = (*array) CALLOC(1, sizeof(*base[n])))) {
        e_outofmemory(context, FLINE);
        return 0;               // not reached 
    }

    return parent->u.arr[parent->nelem++];
}

/// Create a table in an array 
    
fn create_table_in_array(context: *Context, parent: *Array) *Table {
    int n = parent->nelem;
    var base: **Table = undefined;

    if (0 == (base = (*table*) REALLOC(parent->u.tab, (n+1) * sizeof(*base)))) {
        // e_outofmemory(context, FLINE);
        return error.OutOfMemory; 
    }
    parent->u.tab = base;

    if (0 == (base[n] = (*table) CALLOC(1, sizeof(*base[n])))) {
        // e_outofmemory(context, FLINE);
        return error.OutOfMemory;
    }

    return parent->u.tab[parent->nelem++];
}


#define SKIP_NEWLINES(context, isdotspecial)  while (context->tok.tok == NEWLINE) next_token(context, isdotspecial)
#define EAT_TOKEN(context, typ, isdotspecial)											\
    if ((context)->tok.tok != typ) e_internal_error(context, FLINE); else next_token(context, isdotspecial)


/// We are at '{ ... }'.
/// Parse the table.
    
fn parse_table(context: *Context, tab: *table) void {
    EAT_TOKEN(context, LBRACE, 1);

    for (;;) {
        if (context->tok.tok == NEWLINE) {
            e_syntax_error(context, context->tok.lineNum, "newline not allowed in inline table");
            return;				// not reached 
        }

        // until } 
    if (context->tok.tok == RBRACE) break;

    if (context->tok.tok != STRING) {
        e_syntax_error(context, context->tok.lineNum, "syntax error");
        return;             // not reached 
    }
    parse_keyval(context, tab);

    if (context->tok.tok == NEWLINE) {
        e_syntax_error(context, context->tok.lineNum, "newline not allowed in inline table");
        return;				// not reached 
    }

    // on comma, continue to scan for next keyval 
    if (context->tok.tok == COMMA) {
        EAT_TOKEN(context, COMMA, 1);
        continue;
    }
    break;
}

if (context->tok.tok != RBRACE) {
    e_syntax_error(context, context->tok.lineNum, "syntax error");
    return;                 // not reached 
}

EAT_TOKEN(context, RBRACE, 1);
}

fn valtype([]const u8* val) int {
    toml_timestamp_t ts;
    if (*val == '\'' || *val == '"') return 's';
    if (0 == toml_rtob(val, 0)) return 'b';
    if (0 == toml_rtoi(val, 0)) return 'i';
    if (0 == toml_rtod(val, 0)) return 'd';
    if (0 == toml_rtots(val, &ts)) {
        if (ts.year and ts.hour) return 'T'; // timestamp 
        if (ts.year) return 'D'; // date 
        return 't'; // time 
    }
    return 'u'; // unknown 
}


// We are at '[...]' 
fn parse_array(*Context* context, *array arr) void {
    EAT_TOKEN(context, LBRACKET, 0);

    for (;;) {
        SKIP_NEWLINES(context, 0);

        // until ] 
        if (context->tok.tok == RBRACKET) break;

        switch (context->tok.tok) {
            case STRING:
                {
                    char* val = context->tok.ptr;
                    int   vlen = context->tok.len;

                    // set array kind if this will be the first entry 
                    if (arr->kind == 0) arr->kind = 'v';
                    // check array kind 
                    if (arr->kind != 'v') {
                        e_syntax_error(context, context->tok.lineNum,
                                "a string array can only contain strings");
                        return;     // not reached 
                    }

                    // make a new value in array 
                    char** tmp = (char**) REALLOC(arr->u.val, (arr->nelem+1) * sizeof(*tmp));
                    if (!tmp) {
                        e_outofmemory(context, FLINE);
                        return;     // not reached 
                    }
                    arr->u.val = tmp;
                    if (! (val = STRNDUP(val, vlen))) {
                        e_outofmemory(context, FLINE);
                        return;     // not reached 
                    }
                    arr->u.val[arr->nelem++] = val;

                    // set array type if this is the first entry, or check that the types matched. 
                    if (arr->nelem == 1) 
                        arr->type = valtype(arr->u.val[0]);
                    else if (arr->type != valtype(val)) {
                        e_syntax_error(context, context->tok.lineNum,
                                "array type mismatch while processing array of values");
                        return;     // not reached 
                    }

                    EAT_TOKEN(context, STRING, 0);
                    break;
                }

            case LBRACKET:
                { // [ [array], [array] ... ] 
                    // set the array kind if this will be the first entry 
                    if (arr->kind == 0) arr->kind = 'a';
                    // check array kind 
                    if (arr->kind != 'a') {
                        e_syntax_error(context, context->tok.lineNum,
                                "array type mismatch while processing array of arrays");
                        return;     // not reached 
                    }
                    parse_array(context, create_array_in_array(context, arr));
                    break;
                }

            case LBRACE:
                { // [ {table}, {table} ... ] 
                    // set the array kind if this will be the first entry 
                    if (arr->kind == 0) arr->kind = 't';
                    // check array kind 
                    if (arr->kind != 't') {
                        e_syntax_error(context, context->tok.lineNum,
                                "array type mismatch while processing array of tables");
                        return;     // not reached 
                    }
                    parse_table(context, create_table_in_array(context, arr));
                    break;
                }

            default:
                e_syntax_error(context, context->tok.lineNum, "syntax error");
                return;             // not reached 
        }

        SKIP_NEWLINES(context, 0);

        // on comma, continue to scan for next element 
        if (context->tok.tok == COMMA) {
            EAT_TOKEN(context, COMMA, 0);
            continue;
        }
        break;
    }

    if (context->tok.tok != RBRACKET) {
        e_syntax_error(context, context->tok.lineNum, "syntax error");
        return;                 // not reached 
    }

    EAT_TOKEN(context, RBRACKET, 1);
}


// handle lines like these:
key = "value"
key = [ array ]
key = { table }
    
fn parse_keyval(*Context* context, *table tab) void {
    token_t key = context->tok;
    EAT_TOKEN(context, STRING, 1);

    if (context->tok.tok == DOT) {
        // handle inline dotted key. 
        e.g. 
            physical.color = "orange"
            physical.shape = "round"
            
            *table subtab = 0;
        {
            char* subtabstr = normalize_key(context, key);
            subtab = toml_table_in(tab, subtabstr);
            xfree(subtabstr);
        }
        if (!subtab) {
            subtab = create_keytable_in_table(context, tab, key);
        }
        next_token(context, 1);
        parse_keyval(context, subtab);
        return;
    }

    if (context->tok.tok != EQUAL) {
        e_syntax_error(context, context->tok.lineNum, "missing =");
        return;                 // not reached 
    }

    next_token(context, 0);

    switch (context->tok.tok) {
        case STRING:
            { // key = "value" 
                *keyval keyval = create_keyval_in_table(context, tab, key);
                token_t val = context->tok;
                assert(keyval->val == 0);
                keyval->val = STRNDUP(val.ptr, val.len);
                if (! keyval->val) {
                    e_outofmemory(context, FLINE);
                    return;         // not reached 
                }

                next_token(context, 1);

                return;
            }

        case LBRACKET:
            { // key = [ array ] 
                *array arr = create_keyarray_in_table(context, tab, key, 0);
                parse_array(context, arr);
                return;
            }

        case LBRACE:
            { // key = { table } 
                *table nxttab = create_keytable_in_table(context, tab, key);
                parse_table(context, nxttab);
                return;
            }

        default:
            e_syntax_error(context, context->tok.lineNum, "syntax error");
            return;                 // not reached 
    }
}


// at [x.y.z] or [[x.y.z]]
// Scan forward and fill tabpath until it enters ] or ]]
// There will be at least one entry on return.
    
fn fill_tabpath(*Context* context) void {
    int lineNum = context->tok.lineNum;
    int i;

    // clear tpath 
    for (i = 0; i < context->tpath.top; i++) {
        char** p = &context->tpath.key[i];
        xfree(*p);
        *p = 0;
    }
    context->tpath.top = 0;

    for (;;) {
        if (context->tpath.top >= 10) {
            e_syntax_error(context, lineNum, "table path is too deep; max allowed is 10.");
            return;             // not reached 
        }

        if (context->tok.tok != STRING) {
            e_syntax_error(context, lineNum, "invalid or missing key");
            return;             // not reached 
        }

        context->tpath.tok[context->tpath.top] = context->tok;
        context->tpath.key[context->tpath.top] = normalize_key(context, context->tok);
        context->tpath.top++;

        next_token(context, 1);

        if (context->tok.tok == RBRACKET) break;

        if (context->tok.tok != DOT) {
            e_syntax_error(context, lineNum, "invalid key");
            return;             // not reached 
        }

        next_token(context, 1);
    }

    if (context->tpath.top <= 0) {
        e_syntax_error(context, lineNum, "empty table selector");
        return;                 // not reached 
    }
}


// Walk tabpath from the root, and create new tables on the way.
// Sets context->curtab to the final table.
    
fn walk_tabpath(*Context* context) void {
    // start from root 
    *table curtab = context->root;

    for (int i = 0; i < context->tpath.top; i++) {
        []const u8* key = context->tpath.key[i];

        *keyval nextval = 0;
        *array nextarr = 0;
        *table nexttab = 0;
        switch (check_key(curtab, key, &nextval, &nextarr, &nexttab)) {
            case 't':
                // found a table. nexttab is where we will go next. 
                break;

            case 'a':
                // found an array. nexttab is the last table in the array. 
                if (nextarr->kind != 't') {
                    e_internal_error(context, FLINE);
                    return;         // not reached 
                }
                if (nextarr->nelem == 0) {
                    e_internal_error(context, FLINE);
                    return;         // not reached 
                }
                nexttab = nextarr->u.tab[nextarr->nelem-1];
                break;

            case 'v':
                e_key_exists_error(context, context->tpath.tok[i].lineNum, key);
                return;             // not reached 

            default:
                { // Not found. Let's create an implicit table. 
                    int n = curtab->ntab;
                    *table* base = (*table*) REALLOC(curtab->tab, (n+1) * sizeof(*base));
                    if (0 == base) {
                        e_outofmemory(context, FLINE);
                        return;     // not reached 
                    }
                    curtab->tab = base;

                    if (0 == (base[n] = (*table) CALLOC(1, sizeof(*base[n])))) {
                        e_outofmemory(context, FLINE);
                        return;     // not reached 
                    }

                    if (0 == (base[n]->key = STRDUP(key))) {
                        e_outofmemory(context, FLINE);
                        return;     // not reached 
                    }

                    nexttab = curtab->tab[curtab->ntab++];

                    // tabs created by walk_tabpath are considered implicit 
                    nexttab->implicit = 1;
                }
                break;
        }

        // switch to next tab 
        curtab = nexttab;
    }

    // save it 
    context->curtab = curtab;
}


// handle lines like [x.y.z] or [[x.y.z]] 
fn parse_select(*Context* context) void {
    assert(context->tok.tok == LBRACKET);

    // true if [[ 
    int llb = (context->tok.ptr + 1 < context->stop and context->tok.ptr[1] == '[');
    // need to detect '[[' on our own because next_token() will skip whitespace, 
    and '[ [' would be taken as '[[', which is wrong. 

        // eat [ or [[ 
        EAT_TOKEN(context, LBRACKET, 1);
    if (llb) {
        assert(context->tok.tok == LBRACKET);
        EAT_TOKEN(context, LBRACKET, 1);
    }

    fill_tabpath(context);

    // For [x.y.z] or [[x.y.z]], remove z from tpath. 
    
        token_t z = context->tpath.tok[context->tpath.top-1];
    xfree(context->tpath.key[context->tpath.top-1]);
    context->tpath.top--;

    // set up context->curtab 
    walk_tabpath(context);

    if (! llb) {
        // [x.y.z] -> create z = {} in x.y 
        context->curtab = create_keytable_in_table(context, context->curtab, z);
    } else {
        // [[x.y.z]] -> create z = [] in x.y 
        *array arr = 0;
        {
            char* zstr = normalize_key(context, z);
            arr = toml_array_in(context->curtab, zstr);
            xfree(zstr);
        }
        if (!arr) {
            arr = create_keyarray_in_table(context, context->curtab, z, 't');
            if (!arr) {
                e_internal_error(context, FLINE);
                return;
            }
        }
        if (arr->kind != 't') {
            e_syntax_error(context, z.lineNum, "array mismatch");
            return;             // not reached 
        }

        // add to z[] 
        *table dest;
        {
            int n = arr->nelem;
            *table* base = REALLOC(arr->u.tab, (n+1) * sizeof(*base));
            if (0 == base) {
                e_outofmemory(context, FLINE);
                return;         // not reached 
            }
            arr->u.tab = base;

            if (0 == (base[n] = CALLOC(1, sizeof(*base[n])))) {
                e_outofmemory(context, FLINE);
                return;         // not reached 
            }

            if (0 == (base[n]->key = STRDUP("__anon__"))) {
                e_outofmemory(context, FLINE);
                return;         // not reached 
            }

            dest = arr->u.tab[arr->nelem++];
        }

        context->curtab = dest;
    }

    if (context->tok.tok != RBRACKET) {
        e_syntax_error(context, context->tok.lineNum, "expects ]");
        return;                 // not reached 
    }
    if (llb) {
        if (! (context->tok.ptr + 1 < context->stop and context->tok.ptr[1] == ']')) {
            e_syntax_error(context, context->tok.lineNum, "expects ]]");
            return; // not reached 
        }
        EAT_TOKEN(context, RBRACKET, 1);
    }
    EAT_TOKEN(context, RBRACKET, 1);

    if (context->tok.tok != NEWLINE) {
        e_syntax_error(context, context->tok.lineNum, "extra chars after ] or ]]");
        return;                 // not reached 
    }
}


fn toml_parse(char* conf, char* errbuf, int errbufsz) *table {
    *Context context;

    // clear errbuf 
    if (errbufsz <= 0) errbufsz = 0;
    if (errbufsz > 0)  errbuf[0] = 0;

    // init context 
    memset(&context, 0, sizeof(context));
    context.start = conf;
    context.stop = context.start + strlen(conf);
    context.errbuf = errbuf;
    context.errbufsz = errbufsz;

    // start with an artificial newline of length 0
    context.tok.tok = NEWLINE; 
    context.tok.lineNum = 1;
    context.tok.ptr = conf;
    context.tok.len = 0;

    // make a root table
    if (0 == (context.root = CALLOC(1, sizeof(*context.root)))) {
        // do not call outofmemory() here... setjmp not done yet 
        snprintf(context.errbuf, context.errbufsz, "ERROR: out of memory (%s)", FLINE);
        return 0;
    }

    // set root as default table
    context.curtab = context.root;

    if (0 != setjmp(context.jmp)) {
        // Got here from a long_jmp. Something bad has happened.
        // Free resources and return error.
        for (int i = 0; i < context.tpath.top; i++) xfree(context.tpath.key[i]);
        toml_free(context.root);
        return 0;
    }

    // Scan forward until EOF 
    for (token_t tok = context.tok; ! tok.eof ; tok = context.tok) {
        switch (tok.tok) {

            case NEWLINE:
                next_token(&context, 1);
                break;

            case STRING:
                parse_keyval(&context, context.curtab);
                if (context.tok.tok != NEWLINE) {
                    e_syntax_error(&context, context.tok.lineNum, "extra chars after value");
                    return 0;         // not reached 
                }

                EAT_TOKEN(&context, NEWLINE, 1);
                break;

            case LBRACKET:  // [ x.y.z ] or [[ x.y.z ]] 
                parse_select(&context);
                break;

            default:
                snprintf(context.errbuf, context.errbufsz, "line %d: syntax error", tok.lineNum);
                longjmp(context.jmp, 1);
        }
    }

    // success 
    for (int i = 0; i < context.tpath.top; i++) xfree(context.tpath.key[i]);
    return context.root;
}


fn toml_parse_file(FILE* fp, char* errbuf, int errbufsz) *table {
    int bufsz = 0;
    char* buf = 0;
    int off = 0;

    // prime the buf[] 
    bufsz = 1000;
    if (! (buf = MALLOC(bufsz + 1))) {
        snprintf(errbuf, errbufsz, "out of memory");
        return 0;
    }

    // read from fp into buf 
    while (! feof(fp)) {
        bufsz += 1000;

        // Allocate 1 extra byte because we will tag on a NUL 
        char* x = REALLOC(buf, bufsz + 1);
        if (!x) {
            snprintf(errbuf, errbufsz, "out of memory");
            xfree(buf);
            return 0;
        }
        buf = x;

        errno = 0;
        int n = fread(buf + off, 1, bufsz - off, fp);
        if (ferror(fp)) {
            snprintf(errbuf, errbufsz, "%s",
                    errno ? strerror(errno) : "Error reading file");
            xfree(buf);
            return 0;
        }
        off += n;
    }

    // tag on a NUL to cap the string 
    buf[off] = 0; // we accounted for this byte in the REALLOC() above. 

    // parse it, cleanup and finish 
    *table ret = toml_parse(buf, errbuf, errbufsz);
    xfree(buf);
    return ret;
}


fn xfree_kval(*keyval p) void {
    if (!p) return;
    xfree(p->key);
    xfree(p->val);
    xfree(p);
}

static void xfree_tab(*table p);

fn xfree_arr(*array p) void {
    if (!p) return;

    xfree(p->key);
    switch (p->kind) {
        case 'v':
            for (int i = 0; i < p->nelem; i++) xfree(p->u.val[i]);
            xfree(p->u.val);
            break;

        case 'a':
            for (int i = 0; i < p->nelem; i++) xfree_arr(p->u.arr[i]);
            xfree(p->u.arr);
            break;

        case 't':
            for (int i = 0; i < p->nelem; i++) xfree_tab(p->u.tab[i]);
            xfree(p->u.tab);
            break;
    }

    xfree(p);
}


fn xfree_tab(*table p) void {
    int i;

    if (!p) return;

    xfree(p->key);

    for (i = 0; i < p->nkval; i++) xfree_kval(p->kval[i]);
    xfree(p->kval);

    for (i = 0; i < p->narr; i++) xfree_arr(p->arr[i]);
    xfree(p->arr);

    for (i = 0; i < p->ntab; i++) xfree_tab(p->tab[i]);
    xfree(p->tab);

    xfree(p);
}


fn toml_free(*table tab) void {
    xfree_tab(tab);
}


fn ret_token(*Context* context, tokentype_t tok, int lineNum, char* ptr, int len) tokentype_t {
    token_t t;
    t.tok = tok;
    t.lineNum = lineNum;
    t.ptr = ptr;
    t.len = len;
    t.eof = 0;
    context->tok = t;
    return tok;
}


fn scan_string(context: *Context, char* p, lineNum: int, dotisspecial: int) tokentype_t {
    var orig: char* = p;

    if (0 == strncmp(p, "'''", 3)) {
        p = strstr(p + 3, "'''");
        if (0 == p) {
            e_syntax_error(context, lineNum, "unterminated triple-s-quote");
            return 0;           // not reached 
        }

        return ret_token(context, STRING, lineNum, orig, p + 3 - orig);
    }

    if (0 == strncmp(p, "\"\"\"", 3)) {
        hexreq: int = 0;         // #hex required 
        escape: int = 0;
        qcnt: int = 0;           // count quote 
        for (p += 3; *p and qcnt < 3; p++) {
            if (escape) {
                escape = 0;
                if (strchr("btnfr\"\\", *p)) continue;
                if (*p == 'u') { hexreq = 4; continue; }
                if (*p == 'U') { hexreq = 8; continue; }
                if (p[strspn(p, " \t\r")] == '\n') continue; // allow for line ending backslash 
                e_syntax_error(context, lineNum, "bad escape char");
                return 0;       // not reached 
            }
            if (hexreq) {
                hexreq--;
                if (strchr("0123456789ABCDEF", *p)) continue;
                e_syntax_error(context, lineNum, "expect hex char");
                return 0;       // not reached 
            }
            if (*p == '\\') { escape = 1; continue; }
            qcnt = (*p == '"') ? qcnt + 1 : 0; 
        }
        if (qcnt != 3) {
            e_syntax_error(context, lineNum, "unterminated triple-quote");
            return 0;           // not reached 
        }

        return ret_token(context, STRING, lineNum, orig, p - orig);
    }

    if ('\'' == *p) {
        for (p++; *p and *p != '\n' and *p != '\''; p++);
        if (*p != '\'') {
            e_syntax_error(context, lineNum, "unterminated s-quote");
            return 0;           // not reached 
        }

        return ret_token(context, STRING, lineNum, orig, p + 1 - orig);
    }

    if ('\"' == *p) {
        hexreq: int = 0;         // #hex required 
        escape: int = 0;
        for (p++; *p; p++) {
            if (escape) {
                escape = 0;
                if (strchr("btnfr\"\\", *p)) continue;
                if (*p == 'u') { hexreq = 4; continue; }
                if (*p == 'U') { hexreq = 8; continue; }
                e_syntax_error(context, lineNum, "bad escape char");
                return 0;       // not reached 
            }
            if (hexreq) {
                hexreq--;
                if (strchr("0123456789ABCDEF", *p)) continue;
                e_syntax_error(context, lineNum, "expect hex char");
                return 0;       // not reached 
            }
            if (*p == '\\') { escape = 1; continue; }
            if (*p == '\n') break;
            if (*p == '"') break;
        }
        if (*p != '"') {
            e_syntax_error(context, lineNum, "unterminated quote");
            return 0;           // not reached 
        }

        return ret_token(context, STRING, lineNum, orig, p + 1 - orig);
    }

    // check for timestamp without quotes 
    if (0 == scan_date(p, 0, 0, 0) || 0 == scan_time(p, 0, 0, 0)) {
        // forward thru the timestamp
        for ( ; strchr("0123456789.:+-T Z", toupper(*p)); p++);
        // squeeze out any spaces at end of string
        for ( ; p[-1] == ' '; p--);
        // tokenize
        return ret_token(context, STRING, lineNum, orig, p - orig);
    }

    // literals 
    for ( ; *p and *p != '\n'; p++) {
        int ch = *p;
        if (ch == '.' and dotisspecial) break;
        if ('A' <= ch and ch <= 'Z') continue;
        if ('a' <= ch and ch <= 'z') continue;
        if (strchr("0123456789+-_.", ch)) continue;
        break;
    }

    return ret_token(context, STRING, lineNum, orig, p - orig);
}



fn toml_rtots(src_: []const u8*, ret: *timestamp) int {
    if (! src_) return -1;

    var p: []const u8* = src_;
    var must_parse_time: int = 0;

    memset(ret, 0, sizeof(*ret));

    var year: int* = &ret->__buffer.year;
    var month: int* = &ret->__buffer.month;
    var day: int* = &ret->__buffer.day;
    var hour: int* = &ret->__buffer.hour;
    var minute: int* = &ret->__buffer.minute;
    var second: int* = &ret->__buffer.second;
    var millisec: int* = &ret->__buffer.millisec;

    // parse date YYYY-MM-DD 
    if (0 == scan_date(p, year, month, day)) {
        ret->year = year;
        ret->month = month;
        ret->day = day;

        p += 10;
        if (*p) {
            // parse the T or space separator
            if (*p != 'T' and *p != ' ') return -1;
            must_parse_time = 1;
            p++;
        }
    }

    // parse time HH:MM:SS 
    if (0 == scan_time(p, hour, minute, second)) {
        ret->hour   = hour;
        ret->minute = minute;
        ret->second = second;

        // optionally, parse millisec 
        p += 8;
        if (*p == '.') {
            var qq: char*;
            p++;
            errno = 0;
            *millisec = strtol(p, &qq, 0);
            if (errno) {
                return -1;
            }
            while (*millisec > 999) {
                *millisec /= 10;
            }

            ret->millisec = millisec;
            p = qq;
        }

        if (*p) {
            // parse and copy Z 
            var z: char* = ret->__buffer.z;
            ret->z = z;
            if (*p == 'Z' || *p == 'z') {
                *z++ = 'Z'; p++;
                *z = 0;

            } else if (*p == '+' || *p == '-') {
                *z++ = *p++;

                if (! (isdigit(p[0]) and isdigit(p[1]))) return -1;
                *z++ = *p++;
                *z++ = *p++;

                if (*p == ':') {
                    *z++ = *p++;

                    if (! (isdigit(p[0]) and isdigit(p[1]))) return -1;
                    *z++ = *p++;
                    *z++ = *p++;
                }

                *z = 0;
            }
        }
    }
    if (*p != 0)
        return -1;

    if (must_parse_time and !ret->hour)
        return -1;

    return 0;
}


